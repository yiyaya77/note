(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{374:function(n,t,o){"use strict";o.r(t);var e=o(14),s=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"todo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#todo"}},[n._v("#")]),n._v(" todo")]),n._v(" "),t("p",[n._v("compose函数\npipe函数\n缓存函数\n防抖\n节流\n深拷贝（循环引用）\n手写instanceof\n手写confirm组件\n手撕快排\n翻转二叉树")]),n._v(" "),t("p",[n._v("写一个 fetchUrl 方法模拟发出网络请求，并在1s内随机时间，返回1-99随机正整数，同时console.log(url+','+返回值)\nfunction fetchUrl(url: string): Promise"),t("number",[n._v(" {\n// return random number within random time (0 ~ 1second)\n// eg-> url is getData.json，console.log:getData.json, 66\n}")])],1),n._v(" "),t("p",[n._v("实现multifetch函数，要求如下\n按顺序使用fetchurl发出urlist数组中的请求\n支持并行，但返回要按照顺序\n实现控制请求最大并发数maxNum=3的限流逻辑\nfunction multiFetch(urlList: string[]) {\n// do sth. here...\n}\nmultiFetch(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l']).then(() => { console.log('done')\n})\n// expected:\n// a, 15\n// b, 25\n// c, 99\n// d, 55\n// .......")]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[n._v("链式异步调用\nfunction Person(){},使得支持如下调用\nconst p = new Person()\np.sleep(2).work().sleep(3).eat().sleep(5).eat()\n执行效果，3s后控制台输出work，在2s后输出eat，再5s后输出eat，注意不一定是以eat为结束")])]),n._v(" "),t("li",[t("p",[n._v("靓号计算\n请编写一个函数，输入为一个正整数，判断其是否为靓号，靓号的定义：数组中出现连续3个相同的数字，如，11123，,22234\n// n is positive integer\nfunction isBeautyNumber(n)\n{ return true // true or false\n}")])])]),n._v(" "),t("p",[n._v("// test cases\nconsole.log(isBeautyNumber('1113345')) // true\nconsole.log(isBeautyNumber('3872384882')) // false\nconsole.log(isBeautyNumber('111138347')) // true\nconsole.log(isBeautyNumber('113345333')) // true\nconsole.log(isBeautyNumber('1122334455')) // false")]),n._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[n._v("输入为正整数a和正整数b，a<=b，返回a和b（包括a和b本身）之间的所有靓号的数量\nfunction getBeautyNumCount(a, b) {\nreturn 0; }")])]),n._v(" "),t("p",[n._v("如果靓号的定义在原有的基础上，增加连续3个数字123,234,345也符合靓号条件，要如何修改")]),n._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[n._v("字符转换\n完成一个转换函数，将数字转成对应的大写字母，满足下面对应的关系\n1 => A;2 => B;3 => C\n...\n26 => Z;27 => AA;28 => AB;29 => AC ...\n52 => AZ;53 => BA;54 => BB\n...")])]),n._v(" "),t("p",[n._v("// 实现下方函数\nfunction convert(num) { // TODO\n}")]),n._v(" "),t("p",[n._v("// 测试代码\nconst output1 = convert(1);\nconsole.log(output1); // A\nconst output2 = convert(26);\nconsole.log(output2); // Z\nconst output53 = convert(53);\nconsole.log(output53); // BA\nconsole.log(convert(676)); // YZ\nconsole.log(convert(27)) // AA\nconsole.log(convert(28)) // AB\nconsole.log(convert(29)) // AC\nconsole.log(convert(52)) // AZ\nconsole.log(convert(54)) // BB\nconsole.log(convert(17576)) // YYZ")]),n._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[n._v("Event Loop 异步调用顺序\nasync function async1(){ console.log(a1 start) await async2() console.log(a1 end)\n}\nasync function async2(){ console.log(a2)\n}\nconsole.log(begin) setTimeout(function(){\nconsole.log(setTimeout) }，0) async1\n();\nnew Promise(function(resolve){ console.log(p1)\nresolve();\n}).then(function(){ console.log(p2 )\n}) console.log(end)")])]),n._v(" "),t("p",[n._v("//\nscript start async1 start async2 promise1 script end async1 end promise2 setTimeout")]),n._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[n._v("爬楼梯 斐波那契")])]),n._v(" "),t("p",[n._v("二维爬楼梯\n假设有个矩形棋盘，棋盘由x*y个小格子组成，开始时棋子处于左下角，棋子只能向上或者向右边移动一或者两个格子，问有多少种方法可以将棋子移动到右上角（x,y为正整数）")]),n._v(" "),t("p",[n._v("function solution(w, h) { var matrixResult = new Array(w + 1).fill(0).map(() => new Array(h + 1).fill(0))\nmatrixResult[0][0] = 1 matrixResult[0][1] = 1 matrixResult[1][0] = 1\nvar f = function (i, j) {\nlet item\nif (i >=\nitem =\n} return\nitem\n}\nfor (let x\nfor (let\n= 0\n0 && j >= 0) {\nmatrixResult[i][j]\n= 0; x < w; x++) { y = 0; y < h; y++) {\n// 左边两个格子的数字和加上下面两个格子数字和\nconstsum=f(x-1,y)+f(x-2,y)+ f(x,y-1)+f(x,y-2) if (sum !== 0) {\nmatrixResult[x][y] = sum }\n} }\nreturn matrixResult[w - 1][h - 1] }\n// m[x][y] = m[x-1][y] + m[x-2][y] + m[x][y-1] + m[x][y-2]")]),n._v(" "),t("ol",{attrs:{start:"8"}},[t("li",[t("p",[n._v("查找无序数组里面第K大的数")])]),n._v(" "),t("li",[t("p",[n._v("大数相加，相乘")])])]),n._v(" "),t("p",[n._v("function add(a: string, b: string): string { }\nfunction multiply(a: string, b: string): string { }")]),n._v(" "),t("ol",{attrs:{start:"10"}},[t("li",[t("p",[n._v("求质数")])]),n._v(" "),t("li",[t("p",[n._v("实现一个双向链表，包括增加节点，节点遍历和删除节点三项操作")])]),n._v(" "),t("li",[t("p",[n._v("全排列\nfunction print(arr){}")])])]),n._v(" "),t("p",[n._v("3<=arr.length<10 0<arr[i].length<10\n测试：\nconst arr = ['ab', 'mn', '01'] 打印: am0 am1 an0 an1 bm0 bm1 bn0 bn1")]),n._v(" "),t("ol",{attrs:{start:"13"}},[t("li",[n._v("计算平方根\n不使用 Math.sqrt()等 API，手写实现 function sqrt(n:number){}\n测试：\nsqrt(4) // 2\nsqrt(5) // 2.236067977 返回 number，误差不超过10^-\n9 sqrt(0) // 0 sqrt(-1) // NaN sqrt(0.09) // 0.3\n答案:\n经典的二分法递归，需注意0.09的测试用例，与n>1时候的方向不一样，容易忽略，")])])])}),[],!1,null,null,null);t.default=s.exports}}]);